services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    tty: true
    stdin_open: true
    environment:
      MODE: DEV
      BINDING: "0.0.0.0"
      POSTGRES_DATABASE: ${POSTGRES_DB:-oer-aggregator-dev}
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-oer-aggregator-password}
      POSTGRES_PORT: ${POSTGRES_PORT:-5432}
      POSTGRES_USER: ${POSTGRES_USER:-oer-aggregator-user}
      NOSTR_RELAY_URLS: ${NOSTR_RELAY_URLS}
      NOSTR_AMB_RELAY_URL: ${NOSTR_AMB_RELAY_URL}
      IMGPROXY_BASE_URL: ${IMGPROXY_BASE_URL}
      IMGPROXY_KEY: ${IMGPROXY_KEY:-}
      IMGPROXY_SALT: ${IMGPROXY_SALT:-}
    network_mode: host
    volumes:
      - .:/home/node/app
    depends_on:
      - postgres

  postgres:
    image: postgres:15-alpine
    environment:
      PGDATA: /var/lib/postgresql/data/pgdata
      POSTGRES_DB: ${POSTGRES_DB:-oer-aggregator-dev}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-oer-aggregator-password}
      POSTGRES_USER: ${POSTGRES_USER:-oer-aggregator-user}
    network_mode: host
    # Exposing the port is not needed unless you want to access this database instance from the host.
    # Be careful when other postgres docker container are running on the same port
    # ports:
    #  - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/pgdata

  nak-relay:
    build:
      context: https://github.com/fiatjaf/nak.git
    command: serve
    # Always binds to localhost, therefore host mode needs to be used to have access from the other container
    network_mode: host
    restart: unless-stopped
    volumes:
      - ./nak-data:/data
    environment:
      - NAK_DATA_DIR=/data

  imgproxy:
    image: ghcr.io/imgproxy/imgproxy:latest
    network_mode: host
    restart: unless-stopped
    environment:
      # Port configuration (default: 8080)
      IMGPROXY_BIND: ${IMGPROXY_BIND:-:8080}

      # Security: URL signature keys (highly recommended for production)
      # Generate with: echo $(xxd -g 2 -l 64 -p /dev/random | tr -d '\n')
      IMGPROXY_KEY: ${IMGPROXY_KEY:-}
      IMGPROXY_SALT: ${IMGPROXY_SALT:-}

      # Enable URL source processing (required for proxying external images)
      IMGPROXY_ALLOW_ORIGIN: ${IMGPROXY_ALLOW_ORIGIN:-*}

      # Performance and resource limits
      IMGPROXY_MAX_SRC_RESOLUTION: ${IMGPROXY_MAX_SRC_RESOLUTION:-50.0}
      IMGPROXY_MAX_SRC_FILE_SIZE: ${IMGPROXY_MAX_SRC_FILE_SIZE:-20971520}
      IMGPROXY_CONCURRENCY: ${IMGPROXY_CONCURRENCY:-100}

      # Image processing defaults
      IMGPROXY_QUALITY: ${IMGPROXY_QUALITY:-85}
      IMGPROXY_JPEG_PROGRESSIVE: ${IMGPROXY_JPEG_PROGRESSIVE:-true}
      IMGPROXY_PNG_INTERLACED: ${IMGPROXY_PNG_INTERLACED:-true}
      IMGPROXY_ENABLE_WEBP_DETECTION: ${IMGPROXY_ENABLE_WEBP_DETECTION:-true}
      IMGPROXY_ENABLE_AVIF_DETECTION: ${IMGPROXY_ENABLE_AVIF_DETECTION:-true}

      # Development mode (set to empty in production)
      IMGPROXY_DEVELOPMENT_ERRORS_MODE: ${IMGPROXY_DEVELOPMENT_ERRORS_MODE:-true}
    healthcheck:
      test: ["CMD", "imgproxy", "health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s

volumes:
  postgres_data:
